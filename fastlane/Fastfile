# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

before_all do
  ENV['PROFILE'] = "AppSealing Wildcard Distribution Profile"
end

platform :ios do
  desc "Push a new beta build to TestFlight"
  lane :beta do
    require 'net/http'
    require 'uri'
    require 'json'
    require 'jwt'

    # 프로젝트 루트 경로 가져오기 (Fastfile 기준 상위 디렉토리)
    project_root = File.expand_path("..", __dir__)
    fastlane_path = File.expand_path(".", __dir__)

    # App Store Connect API 인증 정보
    KEY_ID = '7327KPS4U8' # App Store Connect에서 발급받은 Key ID
    ISSUER_ID = '69a6de71-4a35-47e3-e053-5b8c7c11a4d1' # App Store Connect에서 발급받은 Issuer ID
    PRIVATE_KEY_PATH = File.join(project_root, "AuthKey_7327KPS4U8.p8")
    unless File.exist?(PRIVATE_KEY_PATH)
      UI.user_error!("Private key file not found at path: #{PRIVATE_KEY_PATH}")
    end

    # Xcode 프로젝트(.xcodeproj) 또는 워크스페이스(.xcworkspace) 파일 자동 검색
    xcode_file_path = Dir.glob(File.join(project_root, "*.xcworkspace")).first || Dir.glob(File.join(project_root, "*.xcodeproj")).first
    if xcode_file_path.nil?
      UI.user_error!("[AppSealing] No Xcode project or workspace found in the project root directory: #{project_root}")
    end

    # 프로젝트 이름 및 스킴 자동 추출
    project_name = File.basename(xcode_file_path, File.extname(xcode_file_path)) # 확장자를 제거한 프로젝트 이름

    # 스킴 자동 검색
    scheme_name = ""
    Dir.chdir(File.dirname(xcode_file_path)) do
      scheme_name = sh("xcodebuild -list -#{xcode_file_path.end_with?('.xcworkspace') ? 'workspace' : 'project'} #{File.basename(xcode_file_path)} | grep 'Schemes:' -A 1 | tail -n 1").strip
    end

    if scheme_name.empty?
      UI.user_error!("[AppSealing] Failed to retrieve scheme name from Xcode project or workspace.")
    end

    UI.message "[AppSealing] Project Name: #{project_name}"
    UI.message "[AppSealing] Scheme Name: #{scheme_name}"

    # 번들 ID 동적으로 추출
    bundle_id = ""
    Dir.chdir(File.dirname(xcode_file_path)) do
      bundle_id_command = "xcodebuild -showBuildSettings -scheme #{scheme_name} | grep 'PRODUCT_BUNDLE_IDENTIFIER' | awk -F ' = ' '{print $2}'"
      bundle_id_output = sh(bundle_id_command).lines.map(&:strip).reject { |line| line.include?("WARNING") || line.empty? }
      bundle_id = bundle_id_output.last.strip
    end

    if bundle_id.empty?
      UI.user_error!("[AppSealing] Failed to retrieve Bundle ID from Xcode project.")
    end

    UI.message "[AppSealing] Bundle ID: #{bundle_id}"

    # Team ID 동적으로 추출
    team_id = ""
    Dir.chdir(File.dirname(xcode_file_path)) do
      team_id_command = "xcodebuild -showBuildSettings -scheme #{scheme_name} | grep 'DEVELOPMENT_TEAM' | awk -F ' = ' '{print $2}'"
      team_id_output = sh(team_id_command).lines.map(&:strip).reject { |line| line.include?("WARNING") || line.empty? }
      team_id = team_id_output.last.strip
    end

    if team_id.empty?
      UI.user_error!("[AppSealing] Failed to retrieve Team ID from Xcode project.")
    end

    UI.message "[AppSealing] Team ID: #{team_id}"

    # JWT 토큰 생성 함수
    def generate_jwt_token(private_key_path)
      private_key = OpenSSL::PKey::EC.new(File.read(private_key_path))
      payload = {
        iss: ISSUER_ID,
        exp: Time.now.to_i + 20 * 60, # 20분 유효기간
        aud: "appstoreconnect-v1"
      }
      header = { kid: KEY_ID }
      JWT.encode(payload, private_key, 'ES256', header)
    end    

    # Xcode 프로젝트에서 CFBundleShortVersionString (마케팅 버전) 가져오기 함수
    def fetch_version_from_xcode(xcodeproj_path, scheme_name)
      version_command = "xcodebuild -project #{xcodeproj_path} -scheme #{scheme_name} -showBuildSettings | grep MARKETING_VERSION | sed 's/[ ]*MARKETING_VERSION = //'"
      version = `#{version_command}`.strip

      if version.empty?
        UI.user_error!("Failed to retrieve MARKETING_VERSION from Xcode project.")
      end

      UI.message("[AppSealing] Retrieved MARKETING_VERSION: #{version}")
      version
    end

    # 최신 빌드 번호 가져오기 함수
    def fetch_latest_build_number(jwt_token, bundle_id, version)
      # App ID 가져오기 (필요 시)
      app_id = fetch_app_id(jwt_token, bundle_id)

      # API 요청 URL
      uri = URI("https://api.appstoreconnect.apple.com/v1/builds?filter[app]=#{app_id}&filter[preReleaseVersion.version]=#{version}&sort=-version")
      request = Net::HTTP::Get.new(uri)
      request['Authorization'] = "Bearer #{jwt_token}"

      # API 요청 실행
      response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
        http.request(request)
      end

      # 응답 처리
      if response.code.to_i == 200
        builds = JSON.parse(response.body)['data']
        if builds && !builds.empty?
          latest_build_number = builds.first['attributes']['version'].to_i
          return latest_build_number
        else
          UI.message("[AppSealing] No builds found for version #{version}.")
        end
      else
        UI.error("[AppSealing] Failed to fetch builds: #{response.code} - #{response.body}")
      end

      nil # 빌드를 찾지 못한 경우 nil 반환
    end

    # App ID 가져오기 함수 (필요 시 사용)
    def fetch_app_id(jwt_token, bundle_id)
      uri = URI("https://api.appstoreconnect.apple.com/v1/apps?filter[bundleId]=#{bundle_id}")
      request = Net::HTTP::Get.new(uri)
      request['Authorization'] = "Bearer #{jwt_token}"

      response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
        http.request(request)
      end

      if response.code.to_i == 200
        apps = JSON.parse(response.body)['data']
        if apps && !apps.empty?
          app_id = apps.first['id']
          return app_id
        else
          UI.user_error!("[AppSealing] No app found with bundle ID: #{bundle_id}")
        end
      else
        UI.error("[AppSealing] Failed to fetch app ID: #{response.code} - #{response.body}")
        UI.user_error!("[AppSealing] Unable to retrieve app ID for bundle ID: #{bundle_id}")
      end

      nil # 앱 ID를 찾지 못한 경우 nil 반환
    end

    # JWT 토큰 생성 및 최신 빌드 번호 가져오기
    jwt_token = generate_jwt_token(PRIVATE_KEY_PATH)
    version = fetch_version_from_xcode(xcode_file_path, scheme_name)
    latest_build_number = fetch_latest_build_number(jwt_token, bundle_id, version)

    if latest_build_number.nil?
      UI.message("[AppSealing] No builds found for version #{version}. Starting with build number 1.")
      new_build_number = 1
    else
      new_build_number = latest_build_number + 1
      UI.message("[AppSealing] Latest Build Number: #{latest_build_number}")
    end

    # 새로운 빌드 번호 설정 (Xcode 프로젝트에 적용)
    increment_build_number(
      build_number: new_build_number,
      xcodeproj: xcode_file_path # Xcode 프로젝트 경로 명시
    )

    UI.message "[AppSealing] Updated Build Number: #{new_build_number}"

    # 빌드 및 IPA 파일 생성
    archive_path = File.join(project_root, "build", "#{project_name}.xcarchive")
    ipa_output_path = File.join(project_root, "build")

    build_ios_app(
      scheme: scheme_name,
      export_method: "app-store",
      clean: true,
      output_directory: ipa_output_path,
      output_name: "#{project_name}.ipa",
      workspace: xcode_file_path.end_with?(".xcworkspace") ? xcode_file_path : nil,
      project: xcode_file_path.end_with?(".xcodeproj") ? xcode_file_path : nil,
      export_options: {
        provisioningProfiles: {
          bundle_id => ENV["PROFILE"]
        }
      },
      xcargs: "CODE_SIGN_STYLE=Manual DEVELOPMENT_TEAM=#{team_id} PROVISIONING_PROFILE_SPECIFIER=\"#{ENV['PROFILE']}\"",
      codesigning_identity: "Apple Distribution"
    )

    # .ipa 파일 경로 설정
    ipa_path = File.join(ipa_output_path, "#{project_name}.ipa")

    unless File.exist?(ipa_path)
      UI.user_error!("[AppSealing] IPA file not found at path: #{ipa_path}")
    end

    UI.message "[AppSealing] IPA Path: #{ipa_path}"

    # generate_hash 스크립트 경로 동적 검색
    generate_hash_script = File.join(project_root, "AppSealingSDK", "Tools", "generate_hash")
    unless File.exist?(generate_hash_script)
      UI.user_error!("[AppSealing] generate_hash script not found at path: #{generate_hash_script}")
    end
    
    # 실행 권한 확인 및 설정
    unless File.executable?(generate_hash_script)
      sh("chmod +x '#{generate_hash_script}'")
    end    
    sh("'#{generate_hash_script}' '#{File.absolute_path(ipa_path)}'")

     # Step 2: Upload the IPA to TestFlight with callback
    begin
      upload_to_testflight(
        ipa: ipa_path,
        # api_key_path: "#{fastlane_path}/AuthKey.json", # JSON 파일 경로,
        api_key: {
          key_id: KEY_ID,
          issuer_id: ISSUER_ID,
          key: File.read(PRIVATE_KEY_PATH)
        },
        skip_waiting_for_build_processing: true, # 빌드 처리 대기 시간 생략
      )      
      UI.success("[AppSealing] Upload to TestFlight completed successfully!")
      
    rescue => e
      UI.error("[AppSealing] Upload to TestFlight failed with error: #{e.message}")
      raise e
      
    ensure
      # Always delete the build directory, even if an error occurs
      if Dir.exist?(ipa_output_path)
        UI.message("[AppSealing] Deleting build directory: #{ipa_output_path}")
        FileUtils.rm_rf(ipa_output_path)
        UI.message("[AppSealing] Build directory deleted.")
      else
        UI.message("[AppSealing] Build directory not found or already deleted.")
      end
    end
  end
end
